"use strict";(self.webpackChunksnnax_docs=self.webpackChunksnnax_docs||[]).push([[914],{6913:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>t});var a=r(4848),s=r(8453);const l={},i="Composed",d={id:"architecture/composed",title:"Composed",description:"The snnax.snn.composed module provides predefined architecture classes that inherit from StatefulModel and can be used to build your model. The predefined architectures include:",source:"@site/content/200_architecture/201_composed.md",sourceDirName:"200_architecture",slug:"/architecture/composed",permalink:"/snnax/architecture/composed",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:201,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/snnax/architecture/intro"},next:{title:"Introduction",permalink:"/snnax/layers/intro"}},o={},t=[{value:"Sequential",id:"sequential",level:2},{value:"Arguments",id:"arguments",level:4},{value:"Example",id:"example",level:4},{value:"Parallel",id:"parallel",level:2},{value:"Arguments",id:"arguments-1",level:4},{value:"Example",id:"example-1",level:4},{value:"CompoundLayer",id:"compoundlayer",level:2},{value:"Arguments",id:"arguments-2",level:4},{value:"Example",id:"example-2",level:4},{value:"SequentialLocalFeedback",id:"sequentiallocalfeedback",level:2},{value:"Arguments",id:"arguments-3",level:4},{value:"Example",id:"example-3",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h4:"h4",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"composed",children:"Composed"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"snnax.snn.composed"})," module provides predefined architecture classes that inherit from ",(0,a.jsx)(n.a,{href:"/snnax/architecture/intro#statefulmodel",children:(0,a.jsx)(n.code,{children:"StatefulModel"})})," and can be used to build your model. The predefined architectures include:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#sequential",children:(0,a.jsx)(n.code,{children:"Sequential"})}),": Constructs a feed-forward spiking neural network."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#parallel",children:(0,a.jsx)(n.code,{children:"Parallel"})}),": Constructs a parallel spiking neural network."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#compoundlayer",children:(0,a.jsx)(n.code,{children:"CompoundLayer"})}),": Groups together several layers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#sequentiallocalfeedback",children:(0,a.jsx)(n.code,{children:"SequentialLocalFeedback"})}),": Constructs a feed-forward spiking neural network with recurrent connections."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"sequential",children:"Sequential"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Sequential"})," class is a simple way to create a feed-forward SNN. It is a subclass of ",(0,a.jsx)(n.code,{children:"StatefulModel"})," and allows the creation of a feed-forward SNN by stacking layers in sequence. It supports the defined ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," neuron types as well as Equinox layers. It constructs a connectivity graph with a feed-forward structure and feeds it to the ",(0,a.jsx)(n.code,{children:"StatefulModel"})," class."]}),"\n",(0,a.jsx)(n.h4,{id:"arguments",children:"Arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": A sequence containing the Equinox modules and SNNAX stateful models in the network order."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forward_fn (Callable)"}),": The forward function used in the ",(0,a.jsx)(n.code,{children:"lax.scan"})," loop to propagate the information through the feed-forward network. The default forward function ",(0,a.jsx)(n.a,{href:"/snnax/functions#default_forward_fn",children:(0,a.jsx)(n.code,{children:"default_forward_fn"})})," is used if not provided."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\r\n    Input--\x3eLinear;\r\n    Linear--\x3eLayerNorm;\r\n    LayerNorm--\x3eLIF;\r\n    LIF--\x3eOutput;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\r\nimport equinox as eqx\r\n\r\nlayers = [\r\n    eqx.Linear(10, 20),\r\n    eqx.LayerNorm(20),\r\n    snn.LIF()\r\n]\r\n\r\nfeed_forward = snn.Sequential(*layers)\r\n\r\n# Equivalent to:\r\nfeed_forward_graph_structure = snn.GraphStructure(\r\n    num_layers=3,\r\n    input_layer_ids=[[0], [], []],\r\n    final_layer_ids=[2],\r\n    input_connectivity=[[], [0], [1]]\r\n)\r\nfeed_forward2 = snn.StatefulModel(\r\n    graph_structure=feed_forward_graph_structure,\r\n    layers=layers\r\n)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"parallel",children:"Parallel"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Parallel"})," class is a simple way to create a parallel SNN. It is a subclass of ",(0,a.jsx)(n.code,{children:"eqx.Module"})," and allows the creation of a parallel SNN by concatenating layers in parallel. The inputs, provided as a list in the same order as the layers, are distributed to each layer. The output is the sum of all layers. It supports the defined ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," neuron types as well as Equinox layers."]}),"\n",(0,a.jsx)(n.h4,{id:"arguments-1",children:"Arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": A sequence containing the Equinox modules and SNNAX stateful models in the network order. The output dimensions of layers must be broadcastable to the same shape under a sum operation."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forward_fn (Callable)"}),": The forward function used in the ",(0,a.jsx)(n.code,{children:"lax.scan"})," loop to propagate the information through the network. The default forward function ",(0,a.jsx)(n.a,{href:"/snnax/functions#default_forward_fn",children:(0,a.jsx)(n.code,{children:"default_forward_fn"})})," is used if not provided."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1. Simple layers"})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\r\n    Input1--\x3eLinear;\r\n    Input2--\x3eLinear;\r\n    Input3--\x3eLinear;\r\n    Input1--\x3eLIF;\r\n    Input2--\x3eLIF;\r\n    Input3--\x3eLIF;\r\n    Linear--\x3eld1((+));\r\n    LIF--\x3eld1((+));\r\n    ld1((+))--\x3eOutput"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\r\nimport equinox as eqx\r\n\r\nlayers = [\r\n    eqx.Linear(10, 20),\r\n    snn.LIF()\r\n]\r\n\r\nparallel = snn.Parallel(*layers)\n"})}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"2. Compound layers"})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR\r\n    Input1--\x3eLinear1\r\n    Input2--\x3eLinear1\r\n    Input3--\x3eLinear1\r\n    subgraph compound1\r\n    Linear1--\x3eLIF1\r\n    end\r\n    LIF1--\x3eld1((+))\r\n    Input1--\x3eLinear2\r\n    Input2--\x3eLinear2\r\n    Input3--\x3eLinear2\r\n    subgraph compound2\r\n    Linear2--\x3eLIF2\r\n    end\r\n    LIF2--\x3eld1((+))\r\n    ld1((+))--\x3eOutput"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\r\nimport equinox as eqx\r\n\r\ncompound1 = snn.CompoundLayer([\r\n    eqx.Linear(10, 20),\r\n    snn.LIF()\r\n])\r\ncompound2 = snn.CompoundLayer([\r\n    eqx.Linear(10, 20),\r\n    snn.LIF()\r\n])\r\nlayers = [compound1, compound2]\r\n\r\nparallel = snn.Parallel(*layers)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"compoundlayer",children:"CompoundLayer"}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"This must be moved to layers"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"CompoundLayer"})," class, a subclass of ",(0,a.jsx)(n.code,{children:"StatefulLayer"}),", groups together several Equinox modules. This is useful for conveniently addressing compound layers as a single entity. It is essentially an Equinox module but with proper handling of the compound state."]}),"\n",(0,a.jsx)(n.h4,{id:"arguments-2",children:"Arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": A sequence containing the Equinox modules and SNNAX stateful layers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"init_fn"}),": Initialization function for the state of the layer."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\r\nimport equinox as eqx\r\n\r\nlayers = [\r\n    eqx.Linear(10, 20),\r\n    eqx.LayerNorm(20),\r\n    snn.LIF()\r\n]\r\n\r\ncompound = snn.CompoundLayer(layers, init_fn)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"sequentiallocalfeedback",children:"SequentialLocalFeedback"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SequentialLocalFeedback"})," class creates a feed-forward SNN with self-recurrent connections. It is a subclass of ",(0,a.jsx)(n.code,{children:"StatefulModel"})," and allows the creation of a feed-forward SNN by stacking layers in sequence. It constructs a connectivity graph with a feed-forward structure and local recurrent connections for each layer and feeds it to the ",(0,a.jsx)(n.code,{children:"StatefulModel"})," class. It supports the defined ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," neuron types as well as Equinox layers."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["By default, when ",(0,a.jsx)(n.code,{children:"feedback_layers"})," is ",(0,a.jsx)(n.code,{children:"None"}),", only ",(0,a.jsx)(n.code,{children:"CompoundLayer"})," instances are recurrently connected to themselves. To connect other layers to themselves, provide a dictionary with the layer indices as keys and the feedback layer indices as values."]})}),"\n",(0,a.jsx)(n.h4,{id:"arguments-3",children:"Arguments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": A sequence containing the layers of the network in causal order."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forward_fn (Callable)"}),": The forward function used in the scan loop. The default forward function ",(0,a.jsx)(n.a,{href:"/snnax/functions#default_forward_fn",children:(0,a.jsx)(n.code,{children:"default_forward_fn"})})," is used if not provided."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"feedback_layers (Optional[Dict[int, int]])"}),": A dictionary specifying which feedback connections to create. If omitted, all ",(0,a.jsx)(n.code,{children:"CompoundLayer"})," instances will be connected to themselves (local feedback)."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["1. ",(0,a.jsx)(n.code,{children:"feedback_layers"})," defined"]})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\r\n    Input--\x3eLinear;\r\n    LayerNorm--\x3eLinear;\r\n    Linear--\x3eLayerNorm;\r\n    LayerNorm--\x3eLIF;\r\n    LIF--\x3eOutput;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\r\nimport equinox as eqx\r\n\r\nlayers = [\r\n    eqx.Linear(10, 20),\r\n    eqx.LayerNorm(20),\r\n    snn.LIF()\r\n]\r\n\r\nfeedback_layers = {1: 0}\r\n\r\nfeed_forward = snn.SequentialLocalFeedback(layers, feedback_layers=feedback_layers)\n"})}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["2. ",(0,a.jsx)(n.code,{children:"feedback_layers"}),"=None"]})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\r\n    Input--\x3eLinear1;\r\n    subgraph compound\r\n        Linear1--\x3eLayerNorm;\r\n        LayerNorm--\x3eLIF1;\r\n        LIF1--\x3eLinear1;\r\n    end\r\n    LIF1--\x3eLinear2;\r\n    Linear2--\x3eLIF2;\r\n    LIF2--\x3eOutput;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\r\nimport equinox as eqx\r\n\r\ncompound = snn.CompoundLayer([\r\n    eqx.Linear(10, 20),\r\n    eqx.LayerNorm(20),\r\n    snn.LIF()\r\n])\r\nlayers = [compound, snn.LIF()]\r\n\r\nfeed_forward = snn.SequentialLocalFeedback(layers, feedback_layers=None)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);