"use strict";(self.webpackChunksnnax_docs=self.webpackChunksnnax_docs||[]).push([[923],{5033:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>t});var a=r(4848),s=r(8453);const l={},o="Composed",i={id:"architecture/composed",title:"Composed",description:"snnax.snn.composed provides predefined architectures classes that inherit from StatefulModel that can be used to build your model.",source:"@site/docs/200_architecture/201_composed.md",sourceDirName:"200_architecture",slug:"/architecture/composed",permalink:"/snnax/architecture/composed",draft:!1,unlisted:!1,editUrl:"https://iffgit.fz-juelich.de/pgi-15/snnax-docs/docs/200_architecture/201_composed.md",tags:[],version:"current",sidebarPosition:201,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/snnax/architecture/intro"},next:{title:"Introduction",permalink:"/snnax/layers/intro"}},d={},t=[{value:"Sequential",id:"sequential",level:2},{value:"Example",id:"example",level:3},{value:"Parallel",id:"parallel",level:2},{value:"Example",id:"example-1",level:3},{value:"CompoundLayer",id:"compoundlayer",level:2},{value:"Example",id:"example-2",level:3},{value:"SequentialLocalFeedback",id:"sequentiallocalfeedback",level:2},{value:"Example",id:"example-3",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"composed",children:"Composed"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"snnax.snn.composed"})," provides predefined architectures classes that inherit from ",(0,a.jsx)(n.a,{href:"/snnax/architecture/intro#statefulmodel",children:(0,a.jsx)(n.code,{children:"StatefulModel"})})," that can be used to build your model.\nThe predefined architectures are:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#sequential",children:(0,a.jsx)(n.code,{children:"Sequential"})}),": construct a feed-forward spiking neural network."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#parallel",children:(0,a.jsx)(n.code,{children:"Parallel"})}),": construct a parallel spiking neural network."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#compoundlayer",children:(0,a.jsx)(n.code,{children:"CompoundLayer"})}),": groups together several layers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/snnax/architecture/composed#sequentiallocalfeedback",children:(0,a.jsx)(n.code,{children:"SequentialLocalFeedback"})}),": construct a feed-forward spiking neural network with recurrent connections."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"sequential",children:"Sequential"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Sequential"})," class is a simple way to create a feed-forward SNN. It is a subclass of ",(0,a.jsx)(n.code,{children:"StatefulModel"})," and allows the creation of a feed-forward SNN by stacking layers in a sequence. It supports the defined ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," neuron types as well as Equinox layers.\nIt constructs a connectivity graph with a ",(0,a.jsx)(n.code,{children:"feed-forward"})," structure and feeds it to the ",(0,a.jsx)(n.code,{children:"StatefulModel"})," class"]}),"\n",(0,a.jsx)(n.p,{children:"It requires the following arguments:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": Sequence containing the equinox modules and snnax stateful models of the network order."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forward_fn (Callable)"}),": Forward function used in the ",(0,a.jsx)(n.code,{children:"lax.scan"})," loop to propagate the information through the feed-forward network. The default forward function ",(0,a.jsx)(n.a,{href:"/snnax/functions/intro",children:(0,a.jsx)(n.code,{children:"default_forward_fn"})})," is used if not provided."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\n    Input--\x3eLinear;\n    Linear--\x3eLayerNorm;\n    LayerNorm--\x3eLIF;\n    LIF--\x3eOutput;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\nimport equinox as eqx\n\nlayers = [eqx.Linear(),\n            eqx.LayerNorm(),\n            snn.LIF()]\n\nfeed_forward = Sequential(*layers)\n\n# Equivalent to\nfeed_forward_graph_structure = snn.GraphStructure(3, [[0], [], []], [2], [[], [0], [1]])\nfeed_forward2 = snn.StatefulModel(graph_structure=graph_structure,\n                                layers=layers)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"parallel",children:"Parallel"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Parallel"})," class is a simple way to create a parallel SNN. It is a subclass of ",(0,a.jsx)(n.code,{children:"eqx.Module"})," and allows the creation of a parallel SNN by concatenating layers in parallel. The inputs provided as a list in the same order as the layers are distributed to each layer. The output is the sum of all layers.\nIt supports the defined ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," neuron types as well as ",(0,a.jsx)(n.code,{children:"Equinox"})," layers."]}),"\n",(0,a.jsx)(n.p,{children:"It requires the following arguments:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": Sequence containing the equinox modules and snnax stateful models of the network order. The order used must be the same as the order used in the ",(0,a.jsx)(n.code,{children:"__call__"})," function. The output dimensions of layers must be broadcastable to the same shape under a sum operation."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forward_fn (Callable)"}),": Forward function used in the ",(0,a.jsx)(n.code,{children:"lax.scan"})," loop to propagate the information through the feed-forward network. The default forward function ",(0,a.jsx)(n.a,{href:"/snnax/functions/intro",children:(0,a.jsx)(n.code,{children:"default_forward_fn"})})," is used if not provided."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1. Simple layers"})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\n    Input1--\x3eLinear;\n    Input2--\x3eLinear;\n    Input3--\x3eLinear;\n    Input1--\x3eLIF;\n    Input2--\x3eLIF;\n    Input3--\x3eLIF;\n    Linear--\x3eld1((+));\n    LIF--\x3eld1((+));\n    ld1((+))--\x3eOutput"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\nimport equinox as eqx\n\nlayers = [eqx.Linear(),\n            snn.LIF()]\n\nparallel = Parallel(*layers)\n"})}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"2. Compound layers"})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR\n    Input1--\x3eLinear1\n    Input2--\x3eLinear1\n    Input3--\x3eLinear1\n    subgraph compound1\n    Linear1--\x3eLIF1\n    end\n    LIF1--\x3eld1((+))\n    Input1--\x3eLinear2\n    Input2--\x3eLinear2\n    Input3--\x3eLinear2\n    subgraph compound2\n    Linear2--\x3eLIF2\n    end\n    LIF2--\x3eld1((+))\n    ld1((+))--\x3eOutput"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\nimport equinox as eqx\n\ncompound1 = snn.CompoundLayer([eqx.Linear(),\n                                snn.LIF()])\ncompound2 = snn.CompoundLayer([eqx.Linear(),\n                                snn.LIF()])\nlayers = [compound1,\n            compound2]\n\nparallel = Parallel(*layers)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"compoundlayer",children:"CompoundLayer"}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"This must be moved to layers"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"CompoundLayer"})," is a subclass of ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," groups together several ",(0,a.jsx)(n.code,{children:"Equinox"})," modules. This is useful for conveniently addressing compound layers as a single one. It is essentially like an Equinox module but with the proper handling of the compound state."]}),"\n",(0,a.jsx)(n.p,{children:"It requires the following arguments:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers (Sequence[eqx.Module])"}),": Sequence containing the equinox modules and SNNAX stateful layers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"init_fn"}),": Initialization function for the state of the layer"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\nimport equinox as eqx\n\nlayers = [eqx.Linear(),\n            eqx.LayerNorm(),\n            snn.LIF()]\n\ncompound = CompoundLayer(layers, init_fn)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"sequentiallocalfeedback",children:"SequentialLocalFeedback"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SequentialLocalFeedback"})," class is a simple way to create a feed-forward SNN with self-recurrent connections. It is a subclass of ",(0,a.jsx)(n.code,{children:"StatefulModel"})," and allows the creation of a feed-forward SNN by stacking layers in a sequence. It constructs a connectivity graph with a ",(0,a.jsx)(n.code,{children:"feed-forward"})," structure and local recurrent connections for each layer and feeds it to the ",(0,a.jsx)(n.code,{children:"StatefulModel"})," class.\nIt supports the defined ",(0,a.jsx)(n.code,{children:"StatefulLayer"})," neuron types as well as Equinox layers."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["By default, when ",(0,a.jsx)(n.code,{children:"feedback_layers"})," is ",(0,a.jsx)(n.code,{children:"None"}),", only ",(0,a.jsx)(n.code,{children:"CompoundLayer"})," are recurrently connected to themselves. If you want to connect other layers to themselves, you need to provide a dictionary with the layer indices as keys and the feedback layer indices as values."]})}),"\n",(0,a.jsx)(n.p,{children:"It requires the following arguments:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"layers"}),": Sequence containing the layers of the network in causal order."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forward_fn"}),": forward function used in the scan loop. default forward function ",(0,a.jsx)(n.code,{children:"default_forward_fn"})," used if not provided"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"feedback_layers"}),": dictionary of which feedback connections to create. If omitted, all CompoundLayers will be connected to themselves (local feedback)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["1. ",(0,a.jsx)(n.code,{children:"feedback_layers"})," defined"]})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\n    Input--\x3eLinear;\n    LayerNorm--\x3eLinear;\n    Linear--\x3eLayerNorm;\n    LayerNorm--\x3eLIF;\n    LIF--\x3eOutput;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\nimport equinox as eqx\n\nlayers = [eqx.Linear(),\n            eqx.LayerNorm(),\n            snn.LIF()]\n\nfeedback_layers = {1: 0}\n\nfeed_forward = snn.SequentialLocalFeedback(layers, feedback_layers=feedback_layers)\n"})}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["2. ",(0,a.jsx)(n.code,{children:"feedback_layers"}),"=None"]})}),"\n",(0,a.jsx)(n.mermaid,{value:"graph LR;\n    Input--\x3eLinear1;\n    subgraph compound\n        Linear1--\x3eLayerNorm;\n        LayerNorm--\x3eLIF1;\n        LIF1--\x3eLinear1;\n    end\n    LIF1--\x3eLinear2;\n    Linear2--\x3eLIF2;\n    LIF2--\x3eOutput;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from snnax import snn\nimport equinox as eqx\n\ncompound = snn.CompoundLayer([eqx.Linear(),\n                                eqx.LayerNorm(),\n                                snn.LIF()])\nlayers = [compound,\n            snn.LIF()]\n\nfeed_forward = snn.SequentialLocalFeedback(layers, feedback_layers=None)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);